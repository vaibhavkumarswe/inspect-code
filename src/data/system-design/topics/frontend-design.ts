import type { SystemDesignTopic } from '../types';

export const frontendTopics: SystemDesignTopic[] = [
  {
    id: 'frontend-architecture',
    title: 'Frontend Architecture Patterns',
    description: 'MVC, MVVM, Flux, and component-based architectures.',
    category: 'frontend',
    difficulty: 'intermediate',
    tags: ['architecture', 'patterns', 'ui'],
    keyPoints: [
      'MVC: Model-View-Controller separation',
      'MVVM: Data binding between View and ViewModel',
      'Flux/Redux: Unidirectional data flow',
      'Component-based: Encapsulated, reusable UI units',
    ],
    diagram: {
      type: 'flow',
      title: 'Flux / Redux Data Flow',
      nodes: [
        { id: 'view', label: 'View (UI)', type: 'primary' },
        { id: 'action', label: 'Action', type: 'default' },
        { id: 'dispatcher', label: 'Dispatcher', type: 'accent' },
        { id: 'store', label: 'Store', type: 'secondary' },
      ],
      edges: [
        { from: 'view', to: 'action', label: 'user interaction' },
        { from: 'action', to: 'dispatcher', label: 'dispatch' },
        { from: 'dispatcher', to: 'store', label: 'update' },
        { from: 'store', to: 'view', label: 're-render' },
      ],
    },
    interviewQuestions: [
      'Compare MVC vs Flux architecture.',
      'Why is unidirectional data flow preferred?',
    ],
  },
  {
    id: 'state-management',
    title: 'State Management',
    description: 'Local state, global state, server state, and URL state.',
    category: 'frontend',
    difficulty: 'intermediate',
    tags: ['react', 'redux', 'state'],
    articleUrl: 'https://kentcdodds.com/blog/application-state-management-with-react',
    keyPoints: [
      'Local state: Component-level (useState)',
      'Global state: App-wide (Redux, Zustand)',
      'Server state: Cached API data (React Query, SWR)',
      'URL state: Route params and search params',
    ],
    interviewQuestions: [
      'When do you need global state management?',
      'Compare Redux vs React Context vs Zustand.',
    ],
  },
  {
    id: 'micro-frontends',
    title: 'Micro Frontends',
    description: 'Breaking frontend monoliths into independently deployable units.',
    category: 'frontend',
    difficulty: 'advanced',
    tags: ['architecture', 'scalability', 'teams'],
    articleUrl: 'https://micro-frontends.org/',
    keyPoints: [
      'Independent deployment per team/feature',
      'Technology agnostic (React, Vue, Angular)',
      'Module federation or iframe-based',
      'Shared design system for consistency',
    ],
    interviewQuestions: [
      'What are the benefits and drawbacks of micro frontends?',
      'How do micro frontends communicate?',
    ],
  },
  {
    id: 'web-performance',
    title: 'Web Performance Optimization',
    description: 'Core Web Vitals, lazy loading, code splitting, and caching.',
    category: 'frontend',
    difficulty: 'intermediate',
    tags: ['performance', 'optimization', 'ux'],
    articleUrl: 'https://web.dev/performance/',
    keyPoints: [
      'LCP: Largest Contentful Paint < 2.5s',
      'FID: First Input Delay < 100ms',
      'CLS: Cumulative Layout Shift < 0.1',
      'Code splitting and lazy loading',
      'Image optimization and responsive images',
    ],
    interviewQuestions: [
      'What are Core Web Vitals?',
      'How do you optimize a slow loading page?',
    ],
  },
  {
    id: 'design-systems',
    title: 'Design Systems',
    description: 'Building consistent, reusable component libraries.',
    category: 'frontend',
    difficulty: 'intermediate',
    tags: ['components', 'consistency', 'reusability'],
    articleUrl: 'https://www.designsystems.com/',
    keyPoints: [
      'Design tokens for colors, spacing, typography',
      'Atomic design: atoms, molecules, organisms',
      'Component documentation and Storybook',
      'Versioning and distribution',
    ],
    interviewQuestions: [
      'How do you structure a design system?',
      'What are design tokens?',
    ],
  },
  {
    id: 'ssr-ssg-csr',
    title: 'SSR vs SSG vs CSR',
    description: 'Server-side rendering, static generation, and client-side rendering.',
    category: 'frontend',
    difficulty: 'intermediate',
    tags: ['rendering', 'performance', 'seo'],
    articleUrl: 'https://web.dev/rendering-on-the-web/',
    keyPoints: [
      'CSR: Renders in browser, poor initial load/SEO',
      'SSR: Renders on server per request, good SEO',
      'SSG: Pre-renders at build time, fastest',
      'ISR: Incremental Static Regeneration (hybrid)',
    ],
    interviewQuestions: [
      'When would you choose SSR over SSG?',
      'How does hydration work in SSR?',
    ],
  },
];
